# **ビット操作と論理演算**

ビット操作や論理演算は、数値をビット単位で直接操作するための重要な技術です。特に低レイヤーなプログラム（ゲームやデバイス制御など）でよく使われます。

---

## **ビットシフト**

### **概要**
ビットシフトは、数値のビット列を左または右に移動させる操作です。  
- 左シフト（`<<`）: 指定した分だけビットを左に移動し、右側を `0` で埋めます。
- 右シフト（`>>`）: 指定した分だけビットを右に移動し、左側を埋めます（埋める値は符号による）。

### **サンプルコード**

```cpp
#include <stdio.h>

int main() {
    unsigned int x = 8; // 0b00001000

    // 1. 左シフト
    printf("x << 1 = %u\n", x << 1); // 0b00010000 → 16
    printf("x << 2 = %u\n", x << 2); // 0b00100000 → 32

    // 2. 右シフト
    printf("x >> 1 = %u\n", x >> 1); // 0b00000100 → 4
    printf("x >> 2 = %u\n", x >> 2); // 0b00000010 → 2

    return 0;
}
```

### **解説**
1. **左シフト**:  
   `x << n` は `x` を2の`n`乗倍します。  
   例: `8 << 1` は `8 * 2 = 16`、`8 << 2` は `8 * 4 = 32` になります。

2. **右シフト**:  
   `x >> n` は `x` を2の`n`乗で割ります（ただし整数切り捨て）。  
   例: `8 >> 1` は `8 / 2 = 4`、`8 >> 2` は `8 / 4 = 2` になります。

---

## **否定（NOT）**

### **概要**

否定は、指定されたビットを反転させる操作です。

### **サンプルコード**

```cpp
#include <stdio.h>

int main() {
    unsigned int x = 8; // 0b00001000

    // 否定
    unsigned int result = ~x;
    printf("~x = %u\n", result); // 0b11110111 → 247

    return 0;
}
```

## **論理和（OR）**

### **概要**
論理和は、2つのビット列の各ビットを比較し、いずれかが `1` の場合に `1` になります。  
演算子は `|` を使用します。

### **サンプルコード**

```cpp
#include <stdio.h>

int main() {
    unsigned int a = 0b1100; // 12
    unsigned int b = 0b1010; // 10

    // 論理和
    unsigned int result = a | b;
    printf("a | b = %u\n", result); // 0b1110 → 14

    return 0;
}
```

### **解説**
```
a = 1100
b = 1010
----------
a | b = 1110 (結果は14)
```

論理和は、複数のビットを一度にセット（有効化）する操作によく使われます。

---

## **論理積（AND）**

### **概要**
論理積は、2つのビット列の各ビットを比較し、両方が `1` の場合にのみ `1` になります。  
演算子は `&` を使用します。

### **サンプルコード**

```cpp
#include <stdio.h>

int main() {
    unsigned int a = 0b1100; // 12
    unsigned int b = 0b1010; // 10

    // 論理積
    unsigned int result = a & b;
    printf("a & b = %u\n", result); // 0b1000 → 8

    return 0;
}
```

### **解説**
```
a = 1100
b = 1010
----------
a & b = 1000 (結果は8)
```

論理積は、特定のビットを取り出す操作（**ビットマスク**）によく使われます。

---

## **応用例: ビットフラグの使用**

ビット演算は、複数の状態を1つの変数で管理する「ビットフラグ」で特に有用です。

### **サンプルコード**

```cpp
#include <stdio.h>

// ビットフラグの定義
#define FLAG_1 0b0001 // フラグ1
#define FLAG_2 0b0010 // フラグ2
#define FLAG_3 0b0100 // フラグ3
#define FLAG_4 0b1000 // フラグ4

int main() {
    unsigned int flags = 0; // 全てのフラグをオフにする

    // 1. フラグをセット
    flags |= FLAG_1; // フラグ1をオン
    flags |= FLAG_3; // フラグ3をオン
    printf("flags = 0b%04x\n", flags); // 0b0101 → 5

    // 2. フラグをチェック
    if (flags & FLAG_1) {
        printf("FLAG_1 is ON\n");
    }
    if (flags & FLAG_2) {
        printf("FLAG_2 is ON\n");
    }

    // 3. フラグを解除
    flags &= ~FLAG_1; // フラグ1をオフ
    printf("flags = 0b%04x\n", flags); // 0b0100 → 4

    return 0;
}
```

### **解説**
1. **フラグをセット**:  
   `flags |= FLAG` を使うことで、特定のビットを `1` にします。

2. **フラグをチェック**:  
   `if (flags & FLAG)` で、特定のビットが `1` か確認できます。

3. **フラグを解除**:  
   `flags &= ~FLAG` を使うことで、特定のビットを `0` にします。
---

## **課題**

### **1日目: ビットシフトを理解する**
- **概要**: 左シフトと右シフトを使用して、2倍と半分の計算を行うプログラムを書いてください。
- **条件**:  
  - 数値 `x = 7` を使用。
  - 左シフトで2倍、右シフトで半分を計算し、結果を表示します。
  - 可能であれば、結果がどうなるのかを実際に確認してみましょう。

---

### **2日目: 否定を理解する**
- **概要**: 否定を用いて、数値を反転させるプログラムを書いてください。
- **条件**:
  - 数値 x を入力とし、それを反転した値を出力します。
  - 可能であれば、結果がどうなるのかを実際に確認してみましょう。

---

### **3日目: 論理和を理解する**
- **概要**: 論理和を用いて、複数のビットをセットするプログラムを書いてください。
- **条件**:
  - 数値 x を入力とし、4ビット目と1ビット目を `1` にセットした値を出力します。
  - 例えば、`x = 0b0110` の場合、結果は `0b1111` になります。
  - 可能であれば、結果がどうなるのかを実際に確認してみましょう。

---

### **2日目: 論理積を理解する**
- **概要**: 論理積を用いて、特定のビット以外を `0` にするプログラムを書いてください。
- **条件**:
  - `unsigned int x = 0b1110` を宣言します。
  - 上から1番目と2番目のビット以外を `0` にします。(`0b1111` → `0b1100`)
  - 可能であれば、結果がどうなるのかを実際に確認してみましょう。

---

### **3日目: 偶数・奇数の判定**
- **概要**: ビット演算を用いて、数値が偶数か奇数かを判定するプログラムを書いてください。
- **条件**:
  - 数値 x を入力とし、偶数の場合は "Even"、奇数の場合は "Odd" を出力します。
  - 一番右のビットが `0` なら偶数、`1` なら奇数と判断します。
  - 可能であれば、結果がどうなるのかを実際に確認してみましょう。

---

### **4日目: 論理和を使ったフラグセット**
- **概要**: 複数のフラグを立てるプログラムを書いてください。
- **条件**:  
  - 4つのフラグ（`FLAG_1` ～ `FLAG_4`）をdefineで定義します。
  - 複数のフラグを格納する変数を定義します。
  - 定義した変数に `FLAG_1` と `FLAG_3` をセットします。
  - 変数を表示します。

---

### **5日目: 論理積を使ったフラグチェック**
- **概要**: 複数のフラグをチェックするプログラムを書いてください。
- **条件**:  
  - `unsigned int flags = 5` を作成します。
  - どのフラグがセットされているのかを調べ、それを表示します。

---